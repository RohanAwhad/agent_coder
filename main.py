import dataclasses
import openai
import os
import re
import yaml

from typing import Optional

# ===
# Utils
# ===
def load_text(fn: str) -> str:
  with open(fn, "r") as f: return f.read()

def save_text(text: str, fn: str) -> None:
  with open(fn, "w") as f: f.write(text)

def append_text(text: str, fn: str) -> None:
  with open(fn, "a") as f: f.write(text)


# ===
# Agents
# ===
@dataclasses.dataclass
class Agent:
  model: str
  sys_prompt: str
  max_tokens: int
  temperature: float = 0.8


requirement_agent = Agent(
  model="Qwen/Qwen2-72B-Instruct",
  sys_prompt=load_text("requirement_engineer.txt"),
  max_tokens=2048,
  temperature=0.8,
)
test_designer_agent = Agent(
  model="deepseek-ai/deepseek-coder-33b-instruct",
  sys_prompt=load_text("test_designer_agent.txt"),
  max_tokens=2048,
  temperature=0.8,
)
programmer_agent = Agent(
  model="deepseek-ai/deepseek-coder-33b-instruct",
  sys_prompt=load_text("programmer_agent.txt"),
  max_tokens=2048,
  temperature=0.8,
)

# ===
# LLM
# ===
client = openai.OpenAI(
  api_key=os.environ.get("TOGETHER_API_KEY"),
  base_url="https://api.together.xyz/v1",
)

@dataclasses.dataclass
class Message:
  role: str
  content: str
  def to_dict(self) -> dict:
    return dataclasses.asdict(self)

class History:
  def __init__(self):
    self.messages: list[Message] = []

  def add(self, role: str, content: str) -> None:
    msg = Message(role=role, content=content)
    self.messages.append(msg)


def generate_response(agent: Agent, prompt: str, history: Optional[History] = None) -> str:
  messages = [{"role": "system", "content": agent.sys_prompt}]
  if history:
    for msg in history.messages: messages.append(msg.to_dict())
  messages.append({"role": "user", "content": prompt.strip()})

  response = client.chat.completions.create(
    model=agent.model,
    messages=messages,
    max_tokens=agent.max_tokens,
    temperature=agent.temperature,
  )
  res = response.choices[0].message.content.strip()
  # if not res.startswith('<planning>'): res = f"<planning>{res}"
  return res


# ===
# Main
# ===
if __name__ == "__main__":
  # test requirements engineer
  job = load_text("test_job1.txt")
  print('Job:', job)
  reqs = generate_response(requirement_agent, job)
  save_text(reqs, "job1_requirements.txt")

  job_reqs = load_text("job1_requirements.txt")
  print('Requirements:', job_reqs)
  # extract str between <yaml> and </yaml> using regex
  pattern = re.compile(r"<yaml>(.*?)</yaml>", re.DOTALL)
  yaml_str = pattern.search(job_reqs).group(1).strip()
  req_dict = yaml.safe_load(yaml_str)

  # # generate tests
  # all_tests = []
  # for reqs in req_dict['requirements']:
  #   tmp = dict(
  #     signature = reqs['function_signature'].strip(),
  #     docstring = reqs['docstring'].strip(),
  #   )
  #   tests = generate_response(test_designer_agent, yaml.dump(tmp))
  #   all_tests.append(tests)
  #   print('Wrote tests for:', reqs['task_description'])

  # save_text("\n---\n".join(all_tests), "job_tests.txt")

  # full_code = load_text("job_tests.txt")
  # pattern = re.compile(r"<python>(.*?)</python>", re.DOTALL)
  # save_text("# This code is generated by AI\n\n", "job_test.py")
  # for split in full_code.split("---"):
  #   code = pattern.search(split).group(1).strip()
  #   append_text(code + '\n\n', "job_test.py")


  # generate code
  all_codes = []
  history = History()
  for reqs in req_dict['requirements']:
    prompt = dict(
      function_signature = reqs['function_signature'].strip(),
      task_description = reqs['task_description'].strip(),
    )
    prompt = yaml.dump(prompt)

    code = generate_response(programmer_agent, prompt, history)
    history.add("user", prompt)
    history.add("assistant", code)

    all_codes.append(code)
    print('Wrote code for:', reqs['task_description'])
    print(code)
    print()

  save_text("\n---\n".join(all_codes), "job1_codes_with_context_2.txt")

  full_code = load_text("job1_codes_with_context_2.txt")
  pattern = re.compile(r"<python>(.*?)</python>", re.DOTALL)
  save_text("# This code is generated by AI\n\n", "job1_codes.py")
  for split in full_code.split("---"):
    code = pattern.search(split).group(1).strip()
    append_text(code + '\n\n', "job1_codes.py")
